import numpy as np


class CAnalyticQCHybrid(object):
    """
    Equations for plotting the found analytical solution

    hbar = 1, m = 1, omega = 1, beta = 1/4, kT = 1/10000
    """
    def __init__(self, p, q):
        """
        Constructor
        :param p:
        :param q:
        :return:
        """
        self.p = p
        self.q = q

        # extract the volume element in the phase space
        p = p.reshape(-1)
        q = p.reshape(-1)

        self.dqdp = (q[1] - q[0]) * (p[1] - p[0])

    def D11(self, t):
        """
        The 11 element of the density matrix
        :param t: time
        :return: numpy.array
        """
        p = self.p
        q = self.q

        #############################################################################################
        #
        # Code generated by Maple (exact_solution.mw) begins
        #
        #############################################################################################

        t1 = 0.1e1 / np.pi
        t2 = q ** 2
        t4 = p ** 2
        t5 = 0.5e1 / 0.4e1 * t2 + t4
        t6 = np.sqrt(5)
        t7 = np.sqrt(4)
        t8 = t7 * t6
        t11 = np.arctan2(q * t8 / 4, p)
        t15 = -t11 + t7 * t6 * t / 4
        t16 = np.cos(t15)
        t17 = t16 ** 2
        t18 = t17 * t5
        t19 = np.sin(t15)
        t20 = t19 ** 2
        t21 = t20 * t5
        t23 = t18 + 0.4e1 / 0.5e1 * t21
        t24 = 0.1e1 / t23
        t25 = 5000 * t18
        t26 = 4000 * t21
        t27 = 1 + t25 + t26
        t29 = np.exp(-t25 - t26)
        t32 = np.sqrt(-t29 * t27 + 1)
        t35 = 0.3e1 / 0.4e1 * t2 + t4
        t36 = np.sqrt(3)
        t37 = t7 * t36
        t40 = np.arctan2(q * t37 / 4, p)
        t44 = -t40 + t7 * t36 * t / 4
        t45 = np.cos(t44)
        t46 = t45 ** 2
        t47 = t46 * t35
        t48 = np.sin(t44)
        t49 = t48 ** 2
        t50 = t49 * t35
        t52 = t47 + 0.4e1 / 0.3e1 * t50
        t53 = 0.1e1 / t52
        t54 = 5000 * t47
        t55 = 0.20000e5 / 0.3e1 * t50
        t56 = 1 + t54 + t55
        t58 = np.exp(-t54 - t55)
        t61 = np.sqrt(-t58 * t56 + 1)
        t64 = abs(t32 * t24 + t61 * t53)
        t65 = t64 ** 2
        t68 = np.sqrt(2)
        t69 = np.sqrt(10000)
        t70 = t69 * t68
        t71 = np.sqrt(t1)
        t79 = t24 * t32 * t71 * t70 / 20000 + t53 * t61 * t71 * t70 / 20000
        t81 = t71 * t70
        t82 = t23 ** 2
        t83 = 0.1e1 / t82
        t84 = t32.conjugate()
        t85 = t84 * t83
        t86 = t17 * q
        t88 = t16 * t5
        t91 = 0.1e1 / p * t7
        t92 = 0.1e1 / t4
        t93 = t92 * t2
        t97 = t19 / (1 + 0.5e1 / 0.4e1 * t93)
        t99 = t97 * t91 * t6 * t88
        t101 = t20 * q
        t103 = 0.5e1 / 0.2e1 * t86 + t99 / 10 + 2 * t101
        t108 = 0.1e1 / t32 * t24
        t112 = 12500 * t86 + 500 * t99 + 10000 * t101
        t120 = (t29 * t112 * t27 - t29 * t112) * t108 * t81 / 40000
        t121 = t52 ** 2
        t122 = 0.1e1 / t121
        t123 = t61.conjugate()
        t124 = t123 * t122
        t125 = t46 * q
        t127 = t45 * t35
        t132 = t48 / (1 + 0.3e1 / 0.4e1 * t93)
        t134 = t132 * t91 * t36 * t127
        t136 = t49 * q
        t138 = 0.3e1 / 0.2e1 * t125 - t134 / 6 + 2 * t136
        t143 = 0.1e1 / t61 * t53
        t147 = 7500 * t125 - 0.2500e4 / 0.3e1 * t134 + 10000 * t136
        t155 = (t58 * t147 * t56 - t58 * t147) * t143 * t81 / 40000
        t159 = t17 * p
        t162 = t92 * q
        t164 = t97 * t162 * t8 * t88
        t166 = t20 * p
        t175 = 10000 * t159 - 500 * t164 + 8000 * t166
        t184 = t46 * p
        t188 = t132 * t162 * t37 * t127
        t190 = t49 * p
        t199 = 10000 * t184 + 0.2500e4 / 0.3e1 * t188 + 0.40000e5 / 0.3e1 * t190
        t208 = -(2 * t159 - t164 / 10 + 0.8e1 / 0.5e1 * t166) * t85 * t81 / 20000 + (
                    t29 * t175 * t27 - t29 * t175) * t108 * t81 / 40000 - (
                           2 * t184 + t188 / 6 + 0.8e1 / 0.3e1 * t190) * t124 * t81 / 20000 + (
                           t58 * t199 * t56 - t58 * t199) * t143 * t81 / 40000
        t222 = np.real(
            (-t103 * t85 * t81 / 20000 + t120 - t138 * t124 * t81 / 20000 + t155) * q * t79 + t208 * p * t79 + complex(
                0, 2) * t208 * (t120 - t103 * t83 * t32 * t81 / 20000 + t155 - t138 * t122 * t61 * t81 / 20000))
        D11 = t65 * t1 / 10000 + t222

        #############################################################################################
        #
        # Code generated by Maple ends
        #
        #############################################################################################

        return D11

    def D12(self, t):
        """
        The 12 element of the hybrid density matrix
        :param t: time
        :return: numpy.array
        """
        p = self.p
        q = self.q

        #############################################################################################
        #
        # Code generated by Maple (exact_solution.mw) begins
        #
        #############################################################################################

        t1 = np.sqrt(2)
        t2 = np.sqrt(10000)
        t3 = t2 * t1
        t5 = np.sqrt(0.1e1 / np.pi)
        t6 = q ** 2
        t8 = p ** 2
        t9 = 0.5e1 / 0.4e1 * t6 + t8
        t10 = np.sqrt(5)
        t11 = np.sqrt(4)
        t12 = t11 * t10
        t15 = np.arctan2(q * t12 / 4, p)
        t19 = -t15 + t11 * t10 * t / 4
        t20 = np.cos(t19)
        t21 = t20 ** 2
        t22 = t21 * t9
        t23 = 5000 * t22
        t24 = np.sin(t19)
        t25 = t24 ** 2
        t26 = t25 * t9
        t27 = 4000 * t26
        t28 = 1 + t23 + t27
        t30 = np.exp(-t23 - t27)
        t33 = np.sqrt(-t30 * t28 + 1)
        t36 = t22 + 0.4e1 / 0.5e1 * t26
        t37 = 0.1e1 / t36
        t39 = t37 * t33 * t5 * t3
        t41 = 0.3e1 / 0.4e1 * t6 + t8
        t42 = np.sqrt(3)
        t43 = t11 * t42
        t46 = np.arctan2(q * t43 / 4, p)
        t50 = -t46 + t11 * t42 * t / 4
        t51 = np.cos(t50)
        t52 = t51 ** 2
        t53 = t52 * t41
        t54 = 5000 * t53
        t55 = np.sin(t50)
        t56 = t55 ** 2
        t57 = t56 * t41
        t58 = 0.20000e5 / 0.3e1 * t57
        t59 = 1 + t54 + t58
        t61 = np.exp(-t54 - t58)
        t64 = np.sqrt(-t61 * t59 + 1)
        t67 = t53 + 0.4e1 / 0.3e1 * t57
        t68 = 0.1e1 / t67
        t70 = t68 * t64 * t5 * t3
        t72 = t39 / 20000 + t70 / 20000
        t75 = (-t70 / 20000 + t39 / 20000).conjugate()
        t78 = t5 * t3
        t80 = 0.1e1 / t33 * t37
        t81 = t21 * q
        t83 = t20 * t9
        t86 = 0.1e1 / p * t11
        t87 = 0.1e1 / t8
        t88 = t87 * t6
        t92 = t24 / (1 + 0.5e1 / 0.4e1 * t88)
        t94 = t92 * t86 * t10 * t83
        t96 = t25 * q
        t98 = 12500 * t81 + 500 * t94 + 10000 * t96
        t106 = (t30 * t98 * t28 - t30 * t98) * t80 * t78 / 40000
        t107 = t36 ** 2
        t108 = 0.1e1 / t107
        t109 = t108 * t33
        t113 = 0.5e1 / 0.2e1 * t81 + t94 / 10 + 2 * t96
        t118 = 0.1e1 / t64 * t68
        t119 = t52 * q
        t121 = t51 * t41
        t126 = t55 / (1 + 0.3e1 / 0.4e1 * t88)
        t128 = t126 * t86 * t42 * t121
        t130 = t56 * q
        t132 = 7500 * t119 - 0.2500e4 / 0.3e1 * t128 + 10000 * t130
        t140 = (t61 * t132 * t59 - t61 * t132) * t118 * t78 / 40000
        t141 = t67 ** 2
        t142 = 0.1e1 / t141
        t143 = t142 * t64
        t147 = 0.3e1 / 0.2e1 * t119 - t128 / 6 + 2 * t130
        t151 = t106 - t113 * t109 * t78 / 20000 + t140 - t147 * t143 * t78 / 20000
        t152 = t64.conjugate()
        t153 = t152 * t142
        t154 = t52 * p
        t157 = t87 * q
        t159 = t126 * t157 * t43 * t121
        t161 = t56 * p
        t163 = 2 * t154 + t159 / 6 + 0.8e1 / 0.3e1 * t161
        t170 = 10000 * t154 + 0.2500e4 / 0.3e1 * t159 + 0.40000e5 / 0.3e1 * t161
        t178 = (t61 * t170 * t59 - t61 * t170) * t118 * t78 / 40000
        t179 = t33.conjugate()
        t180 = t179 * t108
        t181 = t21 * p
        t185 = t92 * t157 * t12 * t83
        t187 = t25 * p
        t189 = 2 * t181 - t185 / 10 + 0.8e1 / 0.5e1 * t187
        t196 = 10000 * t181 - 500 * t185 + 8000 * t187
        t204 = (t30 * t196 * t28 - t30 * t196) * t80 * t78 / 40000
        t205 = t163 * t153 * t78 / 20000 - t178 - t189 * t180 * t78 / 20000 + t204
        t213 = t147 * t153 * t78 / 20000 - t140 - t113 * t180 * t78 / 20000 + t106
        t220 = t204 - t189 * t109 * t78 / 20000 + t178 - t163 * t143 * t78 / 20000
        D12 = 2 * t75 * t72 + complex(0, 1) * (t205 * t151 - t220 * t213) + (t205 * p + t213 * q) * t72 / 2 + (
                    t220 * p + t151 * q) * t75 / 2

        #############################################################################################
        #
        # Code generated by Maple ends
        #
        #############################################################################################

        return D12

    def D22(self, t):
        """
        The 22 element of the hybrid density matrix
        :param t: time
        :return: numpy.array
        """
        p = self.p
        q = self.q

        #############################################################################################
        #
        # Code generated by Maple (exact_solution.mw) begins
        #
        #############################################################################################

        t1 = 0.1e1 / np.pi
        t2 = q ** 2
        t4 = p ** 2
        t5 = 0.3e1 / 0.4e1 * t2 + t4
        t6 = np.sqrt(3)
        t7 = np.sqrt(4)
        t8 = t7 * t6
        t11 = np.arctan2(q * t8 / 4, p)
        t15 = -t11 + t7 * t6 * t / 4
        t16 = np.cos(t15)
        t17 = t16 ** 2
        t18 = t17 * t5
        t19 = np.sin(t15)
        t20 = t19 ** 2
        t21 = t20 * t5
        t23 = t18 + 0.4e1 / 0.3e1 * t21
        t24 = 0.1e1 / t23
        t25 = 5000 * t18
        t26 = 0.20000e5 / 0.3e1 * t21
        t27 = 1 + t25 + t26
        t29 = np.exp(-t25 - t26)
        t32 = np.sqrt(-t29 * t27 + 1)
        t35 = 0.5e1 / 0.4e1 * t2 + t4
        t36 = np.sqrt(5)
        t37 = t7 * t36
        t40 = np.arctan2(q * t37 / 4, p)
        t44 = -t40 + t7 * t36 * t / 4
        t45 = np.cos(t44)
        t46 = t45 ** 2
        t47 = t46 * t35
        t48 = np.sin(t44)
        t49 = t48 ** 2
        t50 = t49 * t35
        t52 = t47 + 0.4e1 / 0.5e1 * t50
        t53 = 0.1e1 / t52
        t54 = 5000 * t47
        t55 = 4000 * t50
        t56 = 1 + t54 + t55
        t58 = np.exp(-t54 - t55)
        t61 = np.sqrt(-t58 * t56 + 1)
        t64 = abs(-t32 * t24 + t61 * t53)
        t65 = t64 ** 2
        t68 = np.sqrt(2)
        t69 = np.sqrt(10000)
        t70 = t69 * t68
        t71 = np.sqrt(t1)
        t79 = -t24 * t32 * t71 * t70 / 20000 + t53 * t61 * t71 * t70 / 20000
        t81 = t71 * t70
        t82 = t23 ** 2
        t83 = 0.1e1 / t82
        t84 = t32.conjugate()
        t85 = t84 * t83
        t86 = t17 * q
        t88 = t16 * t5
        t91 = 0.1e1 / p * t7
        t92 = 0.1e1 / t4
        t93 = t92 * t2
        t97 = t19 / (1 + 0.3e1 / 0.4e1 * t93)
        t99 = t97 * t91 * t6 * t88
        t101 = t20 * q
        t103 = 0.3e1 / 0.2e1 * t86 - t99 / 6 + 2 * t101
        t108 = 0.1e1 / t32 * t24
        t112 = 7500 * t86 - 0.2500e4 / 0.3e1 * t99 + 10000 * t101
        t120 = (t29 * t112 * t27 - t29 * t112) * t108 * t81 / 40000
        t121 = t52 ** 2
        t122 = 0.1e1 / t121
        t123 = t61.conjugate()
        t124 = t123 * t122
        t125 = t46 * q
        t127 = t45 * t35
        t132 = t48 / (1 + 0.5e1 / 0.4e1 * t93)
        t134 = t132 * t91 * t36 * t127
        t136 = t49 * q
        t138 = 0.5e1 / 0.2e1 * t125 + t134 / 10 + 2 * t136
        t143 = 0.1e1 / t61 * t53
        t147 = 12500 * t125 + 500 * t134 + 10000 * t136
        t155 = (t58 * t147 * t56 - t58 * t147) * t143 * t81 / 40000
        t159 = t17 * p
        t162 = t92 * q
        t164 = t97 * t162 * t8 * t88
        t166 = t20 * p
        t175 = 10000 * t159 + 0.2500e4 / 0.3e1 * t164 + 0.40000e5 / 0.3e1 * t166
        t184 = t46 * p
        t188 = t132 * t162 * t37 * t127
        t190 = t49 * p
        t199 = 10000 * t184 - 500 * t188 + 8000 * t190
        t208 = (2 * t159 + t164 / 6 + 0.8e1 / 0.3e1 * t166) * t85 * t81 / 20000 - (
                    t29 * t175 * t27 - t29 * t175) * t108 * t81 / 40000 - (
                           2 * t184 - t188 / 10 + 0.8e1 / 0.5e1 * t190) * t124 * t81 / 20000 + (
                           t58 * t199 * t56 - t58 * t199) * t143 * t81 / 40000
        t222 = np.real(
            (t103 * t85 * t81 / 20000 - t120 - t138 * t124 * t81 / 20000 + t155) * q * t79 + t208 * p * t79 + complex(0,
                                                                                                                      2) * t208 * (
                        -t120 + t103 * t83 * t32 * t81 / 20000 + t155 - t138 * t122 * t61 * t81 / 20000))
        D22 = t65 * t1 / 10000 + t222

        #############################################################################################
        #
        # Code generated by Maple ends
        #
        #############################################################################################

        return D22

    def classical_density(self, t):
        """
        Calculate the classical
        :param t: time
        :return: numpy.array
        """
        rho = self.D11(t) + self.D22(t)

        # Check for the normalization condition
        assert np.allclose(rho.sum() * self.dqdp, 1)

        # Check for the positivity of the density
        assert np.allclose(rho[rho < 0], 0)

        # Make sure all values are real
        assert isinstance(rho[0, 0],  np.float)

        return rho

    def quantum_density(self, t):
        """
        Get the quantum density matrix
        :param t: time
        :return: 2x2 numpy.array
        """
        d12 = self.D12(t).sum()

        rho = np.array(
            [[self.D11(t).sum(), d12], [d12.conjugate(), self.D22(t).sum()]]
        )

        rho *= self.dqdp

        # For the following consistency checks, get eigenvalues
        p = np.linalg.eigvalsh(rho)

        assert np.allclose(p[p < 0], 0), "Quantum density matrix must be non-negative"

        assert np.allclose(p.sum(), 1), "Trace of quantum density matrix must be one"

        return rho

    def quantum_purity(self, t):
        """
        Get the purity of the quantum density matrix
        :param t: time
        :return: float
        """
        rho = self.quantum_density(t)

        return rho.dot(rho).trace().real

########################################################################################################
#
#  Plots
#
########################################################################################################

if __name__ == '__main__':

    import matplotlib.pyplot as plt
    from wigner_normalize import WignerNormalize, WignerSymLogNorm
    from matplotlib.animation import FuncAnimation, writers

    ########################################################################################################
    #
    # Make animation
    #
    ########################################################################################################

    class CVisualizeAnim(object):
        """
        Class for drawing animation
        """
        def __init__(self, fig):

            #################################################################
            #
            # Initialize plotting tools
            #
            #################################################################

            p = np.linspace(-0.1, 0.1, 500)[:, np.newaxis]
            q = np.linspace(-0.1, 0.1, 500)[np.newaxis, :]

            self.hybrid = CAnalyticQCHybrid(p, q)

            img_params = dict(
                extent=[q.min(), q.max(), p.min(), p.max()],
                origin='lower',
                cmap='seismic',
                # norm=WignerNormalize(vmin=-0.1, vmax=0.1)
                norm=WignerSymLogNorm(linthresh=1e-6, vmin=-0.01, vmax=0.1)
            )

            #################################################################
            #
            # Initialize plotting facility
            #
            #################################################################

            self.fig = fig

            self.ax = fig.add_subplot(121)
            self.ax.set_title('Classical density for quantum classical hybrid')

            # generate empty plots
            self.img_classical_density = self.ax.imshow([[0]], **img_params)

            self.ax.set_xlabel('$x$ (a.u.)')
            self.ax.set_ylabel('$p$ (a.u.)')

            ax = fig.add_subplot(122)

            ax.set_title('Quantum purity')
            self.quantum_purity_plot, = ax.plot([0., 40], [1, 0.96])
            ax.set_xlabel('time (a.u.)')
            ax.set_ylabel("quantum purity")

            self.time = []
            self.qpurity = []


        def __call__(self, frame_num):
            """
            Draw a new frame
            :param frame_num: current frame number
            :return: image objects
            """
            # convert the frame number to time
            t = 0.1 * (frame_num)

            # plot the classical density
            self.img_classical_density.set_array(
                self.hybrid.classical_density(t)
            )
            self.ax.set_title('Classical density for quantum classical hybrid\n $t = {:.1f}$ (a.u.)'.format(t))

            # plot quantum purity
            self.time.append(t)
            self.qpurity.append(self.hybrid.quantum_purity(t))

            self.quantum_purity_plot.set_data(self.time, self.qpurity)

            return self.img_classical_density,


    fig = plt.gcf()
    visualizer = CVisualizeAnim(fig)
    animation = FuncAnimation(
        fig, visualizer, frames=np.arange(400), repeat=True, blit=True
    )
    plt.show()

    # If you want to make a movie, comment "plt.show()" out and uncomment the lines bellow

    # Set up formatting for the movie files
    # writer = writers['mencoder'](fps=10, metadata=dict(artist='a good student'), bitrate=-1)

    # Save animation into the file
    # animation.save('classical_density.mp4', writer=writer)

    #######################################################################################################

    #plt.imshow(hybrid.classical_density(0.5), **img_params)
    #plt.ylabel('$p$ (a.u.)')
    #plt.xlabel('$q$ (a.u.)')
    #plt.show()
